// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.


import Foundation

extension Client: SchemasAPI { 
    public func deleteSchema(request: Operations.DeleteSchemaRequest) async throws -> Response<Operations.DeleteSchemaResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureDeleteSchemaRequest(with: configuration, request: request)
            },
            handleResponse: handleDeleteSchemaResponse
        )
    }
    public func downloadSchema(request: Operations.DownloadSchemaRequest) async throws -> Response<Operations.DownloadSchemaResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureDownloadSchemaRequest(with: configuration, request: request)
            },
            handleResponse: handleDownloadSchemaResponse
        )
    }
    public func downloadSchemaRevision(request: Operations.DownloadSchemaRevisionRequest) async throws -> Response<Operations.DownloadSchemaRevisionResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureDownloadSchemaRevisionRequest(with: configuration, request: request)
            },
            handleResponse: handleDownloadSchemaRevisionResponse
        )
    }
    public func getSchema(request: Operations.GetSchemaRequest) async throws -> Response<Operations.GetSchemaResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureGetSchemaRequest(with: configuration, request: request)
            },
            handleResponse: handleGetSchemaResponse
        )
    }
    public func getSchemaDiff(request: Operations.GetSchemaDiffRequest) async throws -> Response<Operations.GetSchemaDiffResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureGetSchemaDiffRequest(with: configuration, request: request)
            },
            handleResponse: handleGetSchemaDiffResponse
        )
    }
    public func getSchemaRevision(request: Operations.GetSchemaRevisionRequest) async throws -> Response<Operations.GetSchemaRevisionResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureGetSchemaRevisionRequest(with: configuration, request: request)
            },
            handleResponse: handleGetSchemaRevisionResponse
        )
    }
    public func getSchemas(request: Operations.GetSchemasRequest) async throws -> Response<Operations.GetSchemasResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureGetSchemasRequest(with: configuration, request: request)
            },
            handleResponse: handleGetSchemasResponse
        )
    }
    public func registerSchema(request: Operations.RegisterSchemaRequest) async throws -> Response<Operations.RegisterSchemaResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureRegisterSchemaRequest(with: configuration, request: request)
            },
            handleResponse: handleRegisterSchemaResponse
        )
    }
}

// MARK: - Request Configuration

private func configureDeleteSchemaRequest(with configuration: URLRequestConfiguration, request: Operations.DeleteSchemaRequest) throws {
    configuration.path = "/v1/apis/{apiID}/version/{versionID}/schema/{revisionID}"
    configuration.method = .delete
    configuration.pathParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureDownloadSchemaRequest(with configuration: URLRequestConfiguration, request: Operations.DownloadSchemaRequest) throws {
    configuration.path = "/v1/apis/{apiID}/version/{versionID}/schema/download"
    configuration.method = .get
    configuration.pathParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureDownloadSchemaRevisionRequest(with configuration: URLRequestConfiguration, request: Operations.DownloadSchemaRevisionRequest) throws {
    configuration.path = "/v1/apis/{apiID}/version/{versionID}/schema/{revisionID}/download"
    configuration.method = .get
    configuration.pathParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureGetSchemaRequest(with configuration: URLRequestConfiguration, request: Operations.GetSchemaRequest) throws {
    configuration.path = "/v1/apis/{apiID}/version/{versionID}/schema"
    configuration.method = .get
    configuration.pathParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureGetSchemaDiffRequest(with configuration: URLRequestConfiguration, request: Operations.GetSchemaDiffRequest) throws {
    configuration.path = "/v1/apis/{apiID}/version/{versionID}/schema/{baseRevisionID}/diff/{targetRevisionID}"
    configuration.method = .get
    configuration.pathParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureGetSchemaRevisionRequest(with configuration: URLRequestConfiguration, request: Operations.GetSchemaRevisionRequest) throws {
    configuration.path = "/v1/apis/{apiID}/version/{versionID}/schema/{revisionID}"
    configuration.method = .get
    configuration.pathParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureGetSchemasRequest(with configuration: URLRequestConfiguration, request: Operations.GetSchemasRequest) throws {
    configuration.path = "/v1/apis/{apiID}/version/{versionID}/schemas"
    configuration.method = .get
    configuration.pathParameterSerializable = request
    configuration.telemetryHeader = .userAgent
}

private func configureRegisterSchemaRequest(with configuration: URLRequestConfiguration, request: Operations.RegisterSchemaRequest) throws {
    configuration.path = "/v1/apis/{apiID}/version/{versionID}/schema"
    configuration.method = .post
    configuration.pathParameterSerializable = request
    let (boundary, formData) = try serializeMultipartFormData(with: request.requestBody)
    configuration.contentType = multipartContentType(with: boundary)
    configuration.body = formData
    if configuration.body == nil {
        throw SerializationError.missingRequiredRequestBody
    }
    configuration.telemetryHeader = .userAgent
}

// MARK: - Response Handlers

private func handleDeleteSchemaResponse(response: Client.APIResponse) throws -> Operations.DeleteSchemaResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
    } else { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .error(try JSONDecoder().decode(Shared.Error.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleDownloadSchemaResponse(response: Client.APIResponse) throws -> Operations.DownloadSchemaResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            return .schema(data)
        }
        if httpResponse.contentType.matchContentType(pattern: "application/x-yaml"), let data = response.data {
            return .schema(data)
        }
    } else { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .error(try JSONDecoder().decode(Shared.Error.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleDownloadSchemaRevisionResponse(response: Client.APIResponse) throws -> Operations.DownloadSchemaRevisionResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            return .schema(data)
        }
        if httpResponse.contentType.matchContentType(pattern: "application/x-yaml"), let data = response.data {
            return .schema(data)
        }
    } else { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .error(try JSONDecoder().decode(Shared.Error.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleGetSchemaResponse(response: Client.APIResponse) throws -> Operations.GetSchemaResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .schema(try JSONDecoder().decode(Shared.Schema.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .error(try JSONDecoder().decode(Shared.Error.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleGetSchemaDiffResponse(response: Client.APIResponse) throws -> Operations.GetSchemaDiffResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .schemaDiff(try JSONDecoder().decode(Shared.SchemaDiff.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .error(try JSONDecoder().decode(Shared.Error.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleGetSchemaRevisionResponse(response: Client.APIResponse) throws -> Operations.GetSchemaRevisionResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .schema(try JSONDecoder().decode(Shared.Schema.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .error(try JSONDecoder().decode(Shared.Error.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleGetSchemasResponse(response: Client.APIResponse) throws -> Operations.GetSchemasResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .schemata(try JSONDecoder().decode([Shared.Schema].self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    } else { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .error(try JSONDecoder().decode(Shared.Error.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleRegisterSchemaResponse(response: Client.APIResponse) throws -> Operations.RegisterSchemaResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
    } else { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .error(try JSONDecoder().decode(Shared.Error.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

