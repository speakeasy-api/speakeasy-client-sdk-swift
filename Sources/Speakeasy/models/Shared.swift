// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

import Foundation

/// Top-level type used for grouping shared models
///
/// > Note: You do not need to interact with this type directly.
public struct Shared {
    private init() {}

    /// Describes the available authentication methods when connecting to the API.
    public enum Security {
        case apiKey(String)
    }

    /// The `Status` type defines a logical error model
    public struct Error {
            /// A developer-facing error message.
        public let message: String
            /// The HTTP status code
        public let statusCode: Int

        /// Creates an object with the specified parameters
        ///
        /// - Parameter message: A developer-facing error message.
        /// - Parameter statusCode: The HTTP status code
        ///
        public init(message: String, statusCode: Int) {
            self.message = message
            self.statusCode = statusCode
        }
    }

    /// An ApiEndpoint is a description of an Endpoint for an API.
    public struct ApiEndpointInput {
            /// The ID of this ApiEndpoint. This is a hash of the method and path.
        public let apiEndpointId: String
            /// A detailed description of the ApiEndpoint.
        public let description: String
            /// A human-readable name for the ApiEndpoint.
        public let displayName: String
            /// HTTP verb.
        public let method: String
            /// Path that handles this Api.
        public let path: String
            /// The version ID of the Api this ApiEndpoint belongs to.
        public let versionId: String

        /// Creates an object with the specified parameters
        ///
        /// - Parameter apiEndpointId: The ID of this ApiEndpoint. This is a hash of the method and path.
        /// - Parameter description: A detailed description of the ApiEndpoint.
        /// - Parameter displayName: A human-readable name for the ApiEndpoint.
        /// - Parameter method: HTTP verb.
        /// - Parameter path: Path that handles this Api.
        /// - Parameter versionId: The version ID of the Api this ApiEndpoint belongs to.
        ///
        public init(apiEndpointId: String, description: String, displayName: String, method: String, path: String, versionId: String) {
            self.apiEndpointId = apiEndpointId
            self.description = description
            self.displayName = displayName
            self.method = method
            self.path = path
            self.versionId = versionId
        }
    }

    /// An ApiEndpoint is a description of an Endpoint for an API.
    public struct ApiEndpoint {
            /// The ID of this ApiEndpoint. This is a hash of the method and path.
        public let apiEndpointId: String
            /// The ID of the Api this ApiEndpoint belongs to.
        public let apiId: String
            /// Creation timestamp.
        @DateTime
        public private(set) var createdAt: Date
            /// A detailed description of the ApiEndpoint.
        public let description: String
            /// A human-readable name for the ApiEndpoint.
        public let displayName: String
            /// HTTP verb.
        public let method: String
            /// Path that handles this Api.
        public let path: String
            /// Last update timestamp.
        @DateTime
        public private(set) var updatedAt: Date
            /// The version ID of the Api this ApiEndpoint belongs to.
        public let versionId: String
            /// The workspace ID this ApiEndpoint belongs to.
        public let workspaceId: String
            /// Determines if the endpoint was found in the OpenAPI spec associated with the parent Api.
        public let matched: Bool?

        /// Creates an object with the specified parameters
        ///
        /// - Parameter apiEndpointId: The ID of this ApiEndpoint. This is a hash of the method and path.
        /// - Parameter apiId: The ID of the Api this ApiEndpoint belongs to.
        /// - Parameter createdAt: Creation timestamp.
        /// - Parameter description: A detailed description of the ApiEndpoint.
        /// - Parameter displayName: A human-readable name for the ApiEndpoint.
        /// - Parameter method: HTTP verb.
        /// - Parameter path: Path that handles this Api.
        /// - Parameter updatedAt: Last update timestamp.
        /// - Parameter versionId: The version ID of the Api this ApiEndpoint belongs to.
        /// - Parameter workspaceId: The workspace ID this ApiEndpoint belongs to.
        /// - Parameter matched: Determines if the endpoint was found in the OpenAPI spec associated with the parent Api.
        ///
        public init(apiEndpointId: String, apiId: String, createdAt: Date, description: String, displayName: String, method: String, path: String, updatedAt: Date, versionId: String, workspaceId: String, matched: Bool? = nil) {
            self.apiEndpointId = apiEndpointId
            self.apiId = apiId
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.description = description
            self.displayName = displayName
            self.method = method
            self.path = path
            self._updatedAt = DateTime<Date>(wrappedValue: updatedAt)
            self.versionId = versionId
            self.workspaceId = workspaceId
            self.matched = matched
        }
    }

    /// OK
    public struct GenerateOpenApiSpecDiff {
        public let currentSchema: String
        public let newSchema: String

        /// Creates an object with the specified parameters
        ///
        ///
        public init(currentSchema: String, newSchema: String) {
            self.currentSchema = currentSchema
            self.newSchema = newSchema
        }
    }

    /// An Api is representation of a API (a collection of API Endpoints) within the Speakeasy Platform.
    public struct ApiInput {
            /// The ID of this Api. This is a human-readable name (subject to change).
        public let apiId: String
            /// A detailed description of the Api.
        public let description: String
            /// The version ID of this Api. This is semantic version identifier.
        public let versionId: String
            /// A set of values associated with a meta_data key. This field is only set on get requests.
        public let metaData: [String: [String]]?

        /// Creates an object with the specified parameters
        ///
        /// - Parameter apiId: The ID of this Api. This is a human-readable name (subject to change).
        /// - Parameter description: A detailed description of the Api.
        /// - Parameter versionId: The version ID of this Api. This is semantic version identifier.
        /// - Parameter metaData: A set of values associated with a meta_data key. This field is only set on get requests.
        ///
        public init(apiId: String, description: String, versionId: String, metaData: [String: [String]]? = nil) {
            self.apiId = apiId
            self.description = description
            self.versionId = versionId
            self.metaData = metaData
        }
    }

    /// An Api is representation of a API (a collection of API Endpoints) within the Speakeasy Platform.
    public struct Api {
            /// The ID of this Api. This is a human-readable name (subject to change).
        public let apiId: String
            /// Creation timestamp.
        @DateTime
        public private(set) var createdAt: Date
            /// A detailed description of the Api.
        public let description: String
            /// Last update timestamp.
        @DateTime
        public private(set) var updatedAt: Date
            /// The version ID of this Api. This is semantic version identifier.
        public let versionId: String
            /// The workspace ID this Api belongs to.
        public let workspaceId: String
            /// Determines if all the endpoints within the Api are found in the OpenAPI spec associated with the Api.
        public let matched: Bool?
            /// A set of values associated with a meta_data key. This field is only set on get requests.
        public let metaData: [String: [String]]?

        /// Creates an object with the specified parameters
        ///
        /// - Parameter apiId: The ID of this Api. This is a human-readable name (subject to change).
        /// - Parameter createdAt: Creation timestamp.
        /// - Parameter description: A detailed description of the Api.
        /// - Parameter updatedAt: Last update timestamp.
        /// - Parameter versionId: The version ID of this Api. This is semantic version identifier.
        /// - Parameter workspaceId: The workspace ID this Api belongs to.
        /// - Parameter matched: Determines if all the endpoints within the Api are found in the OpenAPI spec associated with the Api.
        /// - Parameter metaData: A set of values associated with a meta_data key. This field is only set on get requests.
        ///
        public init(apiId: String, createdAt: Date, description: String, updatedAt: Date, versionId: String, workspaceId: String, matched: Bool? = nil, metaData: [String: [String]]? = nil) {
            self.apiId = apiId
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.description = description
            self._updatedAt = DateTime<Date>(wrappedValue: updatedAt)
            self.versionId = versionId
            self.workspaceId = workspaceId
            self.matched = matched
            self.metaData = metaData
        }
    }

    /// An EmbedAccessTokenResponse contains a token that can be used to embed a Speakeasy dashboard.
    public struct EmbedAccessTokenResponse {
        public let accessToken: String

        /// Creates an object with the specified parameters
        ///
        ///
        public init(accessToken: String) {
            self.accessToken = accessToken
        }
    }

    /// Filters are used to query requests.
    public struct Filters {
            /// A list of filters to apply to the query.
        public let filters: [Shared.Filter]
            /// The maximum number of results to return.
        public let limit: Int
            /// The offset to start the query from.
        public let offset: Int
            /// The operator to use when combining filters.
        public let `operator`: String

        /// Creates an object with the specified parameters
        ///
        /// - Parameter filters: A list of filters to apply to the query.
        /// - Parameter limit: The maximum number of results to return.
        /// - Parameter offset: The offset to start the query from.
        /// - Parameter `operator`: The operator to use when combining filters.
        ///
        public init(filters: [Shared.Filter], limit: Int, offset: Int, operator: String) {
            self.filters = filters
            self.limit = limit
            self.offset = offset
            self.`operator` = `operator`
        }
    }

    /// A filter is a key-value pair that can be used to filter a list of requests.
    public struct Filter {
            /// The key of the filter.
        public let key: String
            /// The operator of the filter.
        public let `operator`: String
            /// The value of the filter.
        public let value: String

        /// Creates an object with the specified parameters
        ///
        /// - Parameter key: The key of the filter.
        /// - Parameter `operator`: The operator of the filter.
        /// - Parameter value: The value of the filter.
        ///
        public init(key: String, operator: String, value: String) {
            self.key = key
            self.`operator` = `operator`
            self.value = value
        }
    }

    /// A representation of an embed token granted for working with Speakeasy components.
    public struct EmbedToken {
            /// Creation timestamp.
        @DateTime
        public private(set) var createdAt: Date
            /// The ID of the user that created this token.
        public let createdBy: String
            /// A detailed description of the EmbedToken.
        public let description: String
            /// The time this token expires.
        @DateTime
        public private(set) var expiresAt: Date
            /// The filters applied to this token.
        public let filters: String
            /// The ID of this EmbedToken.
        public let id: String
            /// The workspace ID this token belongs to.
        public let workspaceId: String
            /// The last time this token was used.
        @DateTime
        public private(set) var lastUsed: Date?
            /// The time this token was revoked.
        @DateTime
        public private(set) var revokedAt: Date?
            /// The ID of the user that revoked this token.
        public let revokedBy: String?

        /// Creates an object with the specified parameters
        ///
        /// - Parameter createdAt: Creation timestamp.
        /// - Parameter createdBy: The ID of the user that created this token.
        /// - Parameter description: A detailed description of the EmbedToken.
        /// - Parameter expiresAt: The time this token expires.
        /// - Parameter filters: The filters applied to this token.
        /// - Parameter id: The ID of this EmbedToken.
        /// - Parameter workspaceId: The workspace ID this token belongs to.
        /// - Parameter lastUsed: The last time this token was used.
        /// - Parameter revokedAt: The time this token was revoked.
        /// - Parameter revokedBy: The ID of the user that revoked this token.
        ///
        public init(createdAt: Date, createdBy: String, description: String, expiresAt: Date, filters: String, id: String, workspaceId: String, lastUsed: Date? = nil, revokedAt: Date? = nil, revokedBy: String? = nil) {
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.createdBy = createdBy
            self.description = description
            self._expiresAt = DateTime<Date>(wrappedValue: expiresAt)
            self.filters = filters
            self.id = id
            self.workspaceId = workspaceId
            self._lastUsed = DateTime<Date?>(wrappedValue: lastUsed)
            self._revokedAt = DateTime<Date?>(wrappedValue: revokedAt)
            self.revokedBy = revokedBy
        }
    }

    /// A set of keys and associated values, attached to a particular version of an Api.
    public struct VersionMetadataInput {
            /// The key for this metadata.
        public let metaKey: String
            /// One of the values for this metadata.
        public let metaValue: String

        /// Creates an object with the specified parameters
        ///
        /// - Parameter metaKey: The key for this metadata.
        /// - Parameter metaValue: One of the values for this metadata.
        ///
        public init(metaKey: String, metaValue: String) {
            self.metaKey = metaKey
            self.metaValue = metaValue
        }
    }

    /// A set of keys and associated values, attached to a particular version of an Api.
    public struct VersionMetadata {
            /// The ID of the Api this Metadata belongs to.
        public let apiId: String
            /// Creation timestamp.
        @DateTime
        public private(set) var createdAt: Date
            /// The key for this metadata.
        public let metaKey: String
            /// One of the values for this metadata.
        public let metaValue: String
            /// The version ID of the Api this Metadata belongs to.
        public let versionId: String
            /// The workspace ID this Metadata belongs to.
        public let workspaceId: String

        /// Creates an object with the specified parameters
        ///
        /// - Parameter apiId: The ID of the Api this Metadata belongs to.
        /// - Parameter createdAt: Creation timestamp.
        /// - Parameter metaKey: The key for this metadata.
        /// - Parameter metaValue: One of the values for this metadata.
        /// - Parameter versionId: The version ID of the Api this Metadata belongs to.
        /// - Parameter workspaceId: The workspace ID this Metadata belongs to.
        ///
        public init(apiId: String, createdAt: Date, metaKey: String, metaValue: String, versionId: String, workspaceId: String) {
            self.apiId = apiId
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.metaKey = metaKey
            self.metaValue = metaValue
            self.versionId = versionId
            self.workspaceId = workspaceId
        }
    }

    /// A plugin is a short script that is run against ingested requests
    public struct Plugin {
        public let code: String
        public let pluginId: String
        public let title: String
        public let workspaceId: String
        @DateTime
        public private(set) var createdAt: Date?
        public let evalHash: String?
        @DateTime
        public private(set) var updatedAt: Date?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(code: String, pluginId: String, title: String, workspaceId: String, createdAt: Date? = nil, evalHash: String? = nil, updatedAt: Date? = nil) {
            self.code = code
            self.pluginId = pluginId
            self.title = title
            self.workspaceId = workspaceId
            self._createdAt = DateTime<Date?>(wrappedValue: createdAt)
            self.evalHash = evalHash
            self._updatedAt = DateTime<Date?>(wrappedValue: updatedAt)
        }
    }

    /// A BoundedRequest is a request that has been logged by the Speakeasy without the contents of the request.
    public struct BoundedRequest {
            /// The ID of the ApiEndpoint this request was made to.
        public let apiEndpointId: String
            /// The ID of the Api this request was made to.
        public let apiId: String
            /// Creation timestamp.
        @DateTime
        public private(set) var createdAt: Date
            /// The ID of the customer that made this request.
        public let customerId: String
            /// The latency of the request.
        public let latency: Int
            /// HTTP verb.
        public let method: String
            /// The path of the request.
        public let path: String
            /// The time the request finished.
        @DateTime
        public private(set) var requestFinishTime: Date
            /// The ID of this request.
        public let requestId: String
            /// The time the request was made.
        @DateTime
        public private(set) var requestStartTime: Date
            /// The status code of the request.
        public let status: Int
            /// The version ID of the Api this request was made to.
        public let versionId: String
            /// The workspace ID this request was made to.
        public let workspaceId: String
            /// Metadata associated with this request
        public let metadata: [Shared.RequestMetadata]?

        /// Creates a request model with the specified parameters
        ///
        /// - Parameter apiEndpointId: The ID of the ApiEndpoint this request was made to.
        /// - Parameter apiId: The ID of the Api this request was made to.
        /// - Parameter createdAt: Creation timestamp.
        /// - Parameter customerId: The ID of the customer that made this request.
        /// - Parameter latency: The latency of the request.
        /// - Parameter method: HTTP verb.
        /// - Parameter path: The path of the request.
        /// - Parameter requestFinishTime: The time the request finished.
        /// - Parameter requestId: The ID of this request.
        /// - Parameter requestStartTime: The time the request was made.
        /// - Parameter status: The status code of the request.
        /// - Parameter versionId: The version ID of the Api this request was made to.
        /// - Parameter workspaceId: The workspace ID this request was made to.
        /// - Parameter metadata: Metadata associated with this request
        ///
        public init(apiEndpointId: String, apiId: String, createdAt: Date, customerId: String, latency: Int, method: String, path: String, requestFinishTime: Date, requestId: String, requestStartTime: Date, status: Int, versionId: String, workspaceId: String, metadata: [Shared.RequestMetadata]? = nil) {
            self.apiEndpointId = apiEndpointId
            self.apiId = apiId
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.customerId = customerId
            self.latency = latency
            self.method = method
            self.path = path
            self._requestFinishTime = DateTime<Date>(wrappedValue: requestFinishTime)
            self.requestId = requestId
            self._requestStartTime = DateTime<Date>(wrappedValue: requestStartTime)
            self.status = status
            self.versionId = versionId
            self.workspaceId = workspaceId
            self.metadata = metadata
        }
    }

    /// Key-Value pairs associated with a request
    public struct RequestMetadata {
        public let key: String?
        public let value: String?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }
    }

    /// An UnboundedRequest represents the HAR content capture by Speakeasy when logging a request.
    public struct UnboundedRequest {
            /// Creation timestamp.
        @DateTime
        public private(set) var createdAt: Date
            /// The HAR content of the request.
        public let har: String
            /// The size of the HAR content in bytes.
        public let harSizeBytes: Int
            /// The ID of this request.
        public let requestId: String
            /// The workspace ID this request was made to.
        public let workspaceId: String

        /// Creates a request model with the specified parameters
        ///
        /// - Parameter createdAt: Creation timestamp.
        /// - Parameter har: The HAR content of the request.
        /// - Parameter harSizeBytes: The size of the HAR content in bytes.
        /// - Parameter requestId: The ID of this request.
        /// - Parameter workspaceId: The workspace ID this request was made to.
        ///
        public init(createdAt: Date, har: String, harSizeBytes: Int, requestId: String, workspaceId: String) {
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.har = har
            self.harSizeBytes = harSizeBytes
            self.requestId = requestId
            self.workspaceId = workspaceId
        }
    }

    /// A Schema represents an API schema for a particular Api and Version.
    public struct Schema {
            /// The ID of the Api this Schema belongs to.
        public let apiId: String
            /// Creation timestamp.
        @DateTime
        public private(set) var createdAt: Date
            /// A detailed description of the Schema.
        public let description: String
            /// An ID referencing this particular revision of the Schema.
        public let revisionId: String
            /// The version ID of the Api this Schema belongs to.
        public let versionId: String
            /// The workspace ID this Schema belongs to.
        public let workspaceId: String

        /// Creates an object with the specified parameters
        ///
        /// - Parameter apiId: The ID of the Api this Schema belongs to.
        /// - Parameter createdAt: Creation timestamp.
        /// - Parameter description: A detailed description of the Schema.
        /// - Parameter revisionId: An ID referencing this particular revision of the Schema.
        /// - Parameter versionId: The version ID of the Api this Schema belongs to.
        /// - Parameter workspaceId: The workspace ID this Schema belongs to.
        ///
        public init(apiId: String, createdAt: Date, description: String, revisionId: String, versionId: String, workspaceId: String) {
            self.apiId = apiId
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.description = description
            self.revisionId = revisionId
            self.versionId = versionId
            self.workspaceId = workspaceId
        }
    }

    /// A model object
    public struct SchemaDiffValueChange {
            /// Represents the previous value of the element.
        public let from: String
            /// Represents the current value of the element.
        public let to: String

        /// Creates an object with the specified parameters
        ///
        /// - Parameter from: Represents the previous value of the element.
        /// - Parameter to: Represents the current value of the element.
        ///
        public init(from: String, to: String) {
            self.from = from
            self.to = to
        }
    }

    /// A SchemaDiff represents a diff of two Schemas.
    public struct SchemaDiff {
            /// Holds every addition change in the diff.
        public let additions: [String]
            /// Holds every deletion change in the diff.
        public let deletions: [String]
            /// Holds every modification change in the diff.
        public let modifications: [String: Shared.SchemaDiffValueChange]

        /// Creates an object with the specified parameters
        ///
        /// - Parameter additions: Holds every addition change in the diff.
        /// - Parameter deletions: Holds every deletion change in the diff.
        /// - Parameter modifications: Holds every modification change in the diff.
        ///
        public init(additions: [String], deletions: [String], modifications: [String: Shared.SchemaDiffValueChange]) {
            self.additions = additions
            self.deletions = deletions
            self.modifications = modifications
        }
    }

}

extension Shared.Error: Codable {
    enum CodingKeys: String, CodingKey {
        case message
        case statusCode = "status_code"
    }
}

extension Shared.ApiEndpointInput: Codable {
    enum CodingKeys: String, CodingKey {
        case apiEndpointId = "api_endpoint_id"
        case description
        case displayName = "display_name"
        case method
        case path
        case versionId = "version_id"
    }
}

extension Shared.ApiEndpoint: Codable {
    enum CodingKeys: String, CodingKey {
        case apiEndpointId = "api_endpoint_id"
        case apiId = "api_id"
        case createdAt = "created_at"
        case description
        case displayName = "display_name"
        case method
        case path
        case updatedAt = "updated_at"
        case versionId = "version_id"
        case workspaceId = "workspace_id"
        case matched
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.apiEndpointId = try container.decode(String.self, forKey: .apiEndpointId)
        self.apiId = try container.decode(String.self, forKey: .apiId)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.description = try container.decode(String.self, forKey: .description)
        self.displayName = try container.decode(String.self, forKey: .displayName)
        self.method = try container.decode(String.self, forKey: .method)
        self.path = try container.decode(String.self, forKey: .path)
        self._updatedAt = try container.decode(DateTime<Date>.self, forKey: .updatedAt)
        self.versionId = try container.decode(String.self, forKey: .versionId)
        self.workspaceId = try container.decode(String.self, forKey: .workspaceId)
        self.matched = try container.decodeIfPresent(Bool.self, forKey: .matched)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.apiEndpointId, forKey: .apiEndpointId)
        try container.encode(self.apiId, forKey: .apiId)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.description, forKey: .description)
        try container.encode(self.displayName, forKey: .displayName)
        try container.encode(self.method, forKey: .method)
        try container.encode(self.path, forKey: .path)
        try container.encode(self._updatedAt, forKey: .updatedAt)
        try container.encode(self.versionId, forKey: .versionId)
        try container.encode(self.workspaceId, forKey: .workspaceId)
        try container.encodeIfPresent(self.matched, forKey: .matched)
    }
}

extension Shared.ApiEndpoint {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
    var updatedAtWrapper: DateTime<Date> {
        return _updatedAt
    }
}

extension Shared.GenerateOpenApiSpecDiff: Codable {
    enum CodingKeys: String, CodingKey {
        case currentSchema = "current_schema"
        case newSchema = "new_schema"
    }
}

extension Shared.ApiInput: Codable {
    enum CodingKeys: String, CodingKey {
        case apiId = "api_id"
        case description
        case versionId = "version_id"
        case metaData = "meta_data"
    }
}

extension Shared.Api: Codable {
    enum CodingKeys: String, CodingKey {
        case apiId = "api_id"
        case createdAt = "created_at"
        case description
        case updatedAt = "updated_at"
        case versionId = "version_id"
        case workspaceId = "workspace_id"
        case matched
        case metaData = "meta_data"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.apiId = try container.decode(String.self, forKey: .apiId)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.description = try container.decode(String.self, forKey: .description)
        self._updatedAt = try container.decode(DateTime<Date>.self, forKey: .updatedAt)
        self.versionId = try container.decode(String.self, forKey: .versionId)
        self.workspaceId = try container.decode(String.self, forKey: .workspaceId)
        self.matched = try container.decodeIfPresent(Bool.self, forKey: .matched)
        self.metaData = try container.decodeIfPresent([String: [String]].self, forKey: .metaData)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.apiId, forKey: .apiId)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.description, forKey: .description)
        try container.encode(self._updatedAt, forKey: .updatedAt)
        try container.encode(self.versionId, forKey: .versionId)
        try container.encode(self.workspaceId, forKey: .workspaceId)
        try container.encodeIfPresent(self.matched, forKey: .matched)
        try container.encodeIfPresent(self.metaData, forKey: .metaData)
    }
}

extension Shared.Api {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
    var updatedAtWrapper: DateTime<Date> {
        return _updatedAt
    }
}

extension Shared.EmbedAccessTokenResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case accessToken = "access_token"
    }
}

extension Shared.Filters: Codable {
    enum CodingKeys: String, CodingKey {
        case filters
        case limit
        case offset
        case `operator` = "operator"
    }
}

extension Shared.Filter: Codable {
    enum CodingKeys: String, CodingKey {
        case key
        case `operator` = "operator"
        case value
    }
}

extension Shared.EmbedToken: Codable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case createdBy = "created_by"
        case description
        case expiresAt = "expires_at"
        case filters
        case id
        case workspaceId = "workspace_id"
        case lastUsed = "last_used"
        case revokedAt = "revoked_at"
        case revokedBy = "revoked_by"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.createdBy = try container.decode(String.self, forKey: .createdBy)
        self.description = try container.decode(String.self, forKey: .description)
        self._expiresAt = try container.decode(DateTime<Date>.self, forKey: .expiresAt)
        self.filters = try container.decode(String.self, forKey: .filters)
        self.id = try container.decode(String.self, forKey: .id)
        self.workspaceId = try container.decode(String.self, forKey: .workspaceId)
        self._lastUsed = try container.decodeIfPresent(DateTime<Date?>.self, forKey: .lastUsed) ?? DateTime<Date?>(wrappedValue: nil)
        self._revokedAt = try container.decodeIfPresent(DateTime<Date?>.self, forKey: .revokedAt) ?? DateTime<Date?>(wrappedValue: nil)
        self.revokedBy = try container.decodeIfPresent(String.self, forKey: .revokedBy)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.createdBy, forKey: .createdBy)
        try container.encode(self.description, forKey: .description)
        try container.encode(self._expiresAt, forKey: .expiresAt)
        try container.encode(self.filters, forKey: .filters)
        try container.encode(self.id, forKey: .id)
        try container.encode(self.workspaceId, forKey: .workspaceId)
        if self.lastUsed != nil {
            try container.encode(self._lastUsed, forKey: .lastUsed)
        }
        if self.revokedAt != nil {
            try container.encode(self._revokedAt, forKey: .revokedAt)
        }
        try container.encodeIfPresent(self.revokedBy, forKey: .revokedBy)
    }
}

extension Shared.EmbedToken {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
    var expiresAtWrapper: DateTime<Date> {
        return _expiresAt
    }
    var lastUsedWrapper: DateTime<Date?> {
        return _lastUsed
    }
    var revokedAtWrapper: DateTime<Date?> {
        return _revokedAt
    }
}

extension Shared.VersionMetadataInput: Codable {
    enum CodingKeys: String, CodingKey {
        case metaKey = "meta_key"
        case metaValue = "meta_value"
    }
}

extension Shared.VersionMetadata: Codable {
    enum CodingKeys: String, CodingKey {
        case apiId = "api_id"
        case createdAt = "created_at"
        case metaKey = "meta_key"
        case metaValue = "meta_value"
        case versionId = "version_id"
        case workspaceId = "workspace_id"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.apiId = try container.decode(String.self, forKey: .apiId)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.metaKey = try container.decode(String.self, forKey: .metaKey)
        self.metaValue = try container.decode(String.self, forKey: .metaValue)
        self.versionId = try container.decode(String.self, forKey: .versionId)
        self.workspaceId = try container.decode(String.self, forKey: .workspaceId)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.apiId, forKey: .apiId)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.metaKey, forKey: .metaKey)
        try container.encode(self.metaValue, forKey: .metaValue)
        try container.encode(self.versionId, forKey: .versionId)
        try container.encode(self.workspaceId, forKey: .workspaceId)
    }
}

extension Shared.VersionMetadata {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
}

extension Shared.Plugin: Codable {
    enum CodingKeys: String, CodingKey {
        case code
        case pluginId = "plugin_id"
        case title
        case workspaceId = "workspace_id"
        case createdAt = "created_at"
        case evalHash = "eval_hash"
        case updatedAt = "updated_at"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.code = try container.decode(String.self, forKey: .code)
        self.pluginId = try container.decode(String.self, forKey: .pluginId)
        self.title = try container.decode(String.self, forKey: .title)
        self.workspaceId = try container.decode(String.self, forKey: .workspaceId)
        self._createdAt = try container.decodeIfPresent(DateTime<Date?>.self, forKey: .createdAt) ?? DateTime<Date?>(wrappedValue: nil)
        self.evalHash = try container.decodeIfPresent(String.self, forKey: .evalHash)
        self._updatedAt = try container.decodeIfPresent(DateTime<Date?>.self, forKey: .updatedAt) ?? DateTime<Date?>(wrappedValue: nil)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.code, forKey: .code)
        try container.encode(self.pluginId, forKey: .pluginId)
        try container.encode(self.title, forKey: .title)
        try container.encode(self.workspaceId, forKey: .workspaceId)
        if self.createdAt != nil {
            try container.encode(self._createdAt, forKey: .createdAt)
        }
        try container.encodeIfPresent(self.evalHash, forKey: .evalHash)
        if self.updatedAt != nil {
            try container.encode(self._updatedAt, forKey: .updatedAt)
        }
    }
}

extension Shared.Plugin {
    var createdAtWrapper: DateTime<Date?> {
        return _createdAt
    }
    var updatedAtWrapper: DateTime<Date?> {
        return _updatedAt
    }
}

extension Shared.BoundedRequest: Codable {
    enum CodingKeys: String, CodingKey {
        case apiEndpointId = "api_endpoint_id"
        case apiId = "api_id"
        case createdAt = "created_at"
        case customerId = "customer_id"
        case latency
        case method
        case path
        case requestFinishTime = "request_finish_time"
        case requestId = "request_id"
        case requestStartTime = "request_start_time"
        case status
        case versionId = "version_id"
        case workspaceId = "workspace_id"
        case metadata
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.apiEndpointId = try container.decode(String.self, forKey: .apiEndpointId)
        self.apiId = try container.decode(String.self, forKey: .apiId)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.customerId = try container.decode(String.self, forKey: .customerId)
        self.latency = try container.decode(Int.self, forKey: .latency)
        self.method = try container.decode(String.self, forKey: .method)
        self.path = try container.decode(String.self, forKey: .path)
        self._requestFinishTime = try container.decode(DateTime<Date>.self, forKey: .requestFinishTime)
        self.requestId = try container.decode(String.self, forKey: .requestId)
        self._requestStartTime = try container.decode(DateTime<Date>.self, forKey: .requestStartTime)
        self.status = try container.decode(Int.self, forKey: .status)
        self.versionId = try container.decode(String.self, forKey: .versionId)
        self.workspaceId = try container.decode(String.self, forKey: .workspaceId)
        self.metadata = try container.decodeIfPresent([Shared.RequestMetadata].self, forKey: .metadata)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.apiEndpointId, forKey: .apiEndpointId)
        try container.encode(self.apiId, forKey: .apiId)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.customerId, forKey: .customerId)
        try container.encode(self.latency, forKey: .latency)
        try container.encode(self.method, forKey: .method)
        try container.encode(self.path, forKey: .path)
        try container.encode(self._requestFinishTime, forKey: .requestFinishTime)
        try container.encode(self.requestId, forKey: .requestId)
        try container.encode(self._requestStartTime, forKey: .requestStartTime)
        try container.encode(self.status, forKey: .status)
        try container.encode(self.versionId, forKey: .versionId)
        try container.encode(self.workspaceId, forKey: .workspaceId)
        try container.encodeIfPresent(self.metadata, forKey: .metadata)
    }
}

extension Shared.BoundedRequest {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
    var requestFinishTimeWrapper: DateTime<Date> {
        return _requestFinishTime
    }
    var requestStartTimeWrapper: DateTime<Date> {
        return _requestStartTime
    }
}

extension Shared.RequestMetadata: Codable {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }
}

extension Shared.UnboundedRequest: Codable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case har
        case harSizeBytes = "har_size_bytes"
        case requestId = "request_id"
        case workspaceId = "workspace_id"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.har = try container.decode(String.self, forKey: .har)
        self.harSizeBytes = try container.decode(Int.self, forKey: .harSizeBytes)
        self.requestId = try container.decode(String.self, forKey: .requestId)
        self.workspaceId = try container.decode(String.self, forKey: .workspaceId)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.har, forKey: .har)
        try container.encode(self.harSizeBytes, forKey: .harSizeBytes)
        try container.encode(self.requestId, forKey: .requestId)
        try container.encode(self.workspaceId, forKey: .workspaceId)
    }
}

extension Shared.UnboundedRequest {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
}

extension Shared.Schema: Codable {
    enum CodingKeys: String, CodingKey {
        case apiId = "api_id"
        case createdAt = "created_at"
        case description
        case revisionId = "revision_id"
        case versionId = "version_id"
        case workspaceId = "workspace_id"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.apiId = try container.decode(String.self, forKey: .apiId)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.description = try container.decode(String.self, forKey: .description)
        self.revisionId = try container.decode(String.self, forKey: .revisionId)
        self.versionId = try container.decode(String.self, forKey: .versionId)
        self.workspaceId = try container.decode(String.self, forKey: .workspaceId)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.apiId, forKey: .apiId)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.description, forKey: .description)
        try container.encode(self.revisionId, forKey: .revisionId)
        try container.encode(self.versionId, forKey: .versionId)
        try container.encode(self.workspaceId, forKey: .workspaceId)
    }
}

extension Shared.Schema {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
}

extension Shared.SchemaDiffValueChange: Codable {
    enum CodingKeys: String, CodingKey {
        case from = "From"
        case to = "To"
    }
}

extension Shared.SchemaDiff: Codable {
    enum CodingKeys: String, CodingKey {
        case additions
        case deletions
        case modifications
    }
}